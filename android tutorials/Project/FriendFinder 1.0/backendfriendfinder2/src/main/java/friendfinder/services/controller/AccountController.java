package friendfinder.services.controller;

import friendfinder.domain.Account;
import friendfinder.domain.User;
import friendfinder.exceptions.HttpConflictException;
import friendfinder.exceptions.HttpNotFoundException;
import friendfinder.exceptions.HttpUnprocessableEntityException;
import friendfinder.persistence.AccountRepository;
import org.apache.catalina.mapper.Mapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import static org.apache.commons.lang3.StringUtils.isBlank;

/**
 * Created by grace on 23/06/17.
 */
@RestController    // This means that this class is a Controller
@RequestMapping(path="/account") // This means URL's start with /account (after Application path)
public class AccountController {

    private static final Logger log = LoggerFactory.getLogger(AccountController.class);

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AccountRepository accountRepository;

    @GetMapping(path="/all")
    public Iterable<Account> getAllAccounts() {
        // This returns a JSON with the accounts
        log.debug("Getting all accounts");

        return accountRepository.findAll();
    }

    @GetMapping
    public Account loginAccount (@RequestParam(value = "email") String email,
                              @RequestParam(value = "password") String password) {
        log.debug("Getting the account by email and password");
        Account serchedEntity = null;
        try {
            if (isBlank(email) || isBlank(password)) {
                throw new HttpUnprocessableEntityException("Email or password is blank.");
            }
            serchedEntity = accountRepository.findByEmailAndPassword(email, password);

            if (serchedEntity == null) {
                log.debug("Account does not exist.");
                throw new HttpNotFoundException("Entity was not found");
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return serchedEntity;
    }

    @PostMapping
    public Account registerAccount (@RequestBody Account entity) {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        Account newEntity = null;
        try {
            if (entity == null || isBlank(entity.getEmail()) || isBlank(entity.getPassword())) {
                throw new HttpUnprocessableEntityException("Entity, email or password is blank.");
            }
            newEntity = accountRepository.findByEmail(entity.getEmail());

            if (newEntity != null) {
                log.debug("Entity already registered.");
                throw new HttpConflictException("Entity already registered.");
            }
            log.debug("Creating an Entity");

            User usr = new User(entity);
            entity.setUser(usr);
            accountRepository.save(entity);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return newEntity;
    }

    @PutMapping(value = "/{accountId}")
    public Account updateAccount (@PathVariable(value = "accountId") Integer accountId,
                                 @RequestBody Account entity) {
        log.debug("Updating an account");
        Account entityBefore = null;
        try {
            entityBefore = accountRepository.findByAccountId(accountId);
            if (entityBefore == null) {
                throw new HttpNotFoundException("Entity was not found");
            }
            entity.setAccountId(accountId);
            entity.setCreatedAt(entityBefore.getCreatedAt());
            accountRepository.save(entity);
        } catch (Exception ex) {
            ex.printStackTrace();
            log.debug("Error updating the Entity: " + ex.toString());
        }
        return entity;
    }

    @DeleteMapping(value = "/{accountId}")
    public void deleteAccount (@PathVariable(value = "accountId") Integer accountId) {
        log.debug("Deleting an account");
        Account deleteEntity = null;
        try {
            deleteEntity = accountRepository.findByAccountId(accountId);
            if (deleteEntity == null) {
                throw new HttpNotFoundException("Entity was not found");
            }
            accountRepository.delete(deleteEntity);
        } catch (Exception ex) {
            log.debug("Error deleting the Account: " + ex.toString());
        }
    }
}
