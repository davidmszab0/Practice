package friendfinder.services.controller;

import friendfinder.domain.Account;
import friendfinder.domain.User;
import friendfinder.exceptions.HttpUnprocessableEntityException;
import friendfinder.persistence.AccountRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import static org.apache.commons.lang3.StringUtils.isBlank;

/**
 * Created by grace on 23/06/17.
 */
@RestController    // This means that this class is a Controller
@RequestMapping(path="/account") // This means URL's start with /account (after Application path)
public class AccountController {

    private static final Logger log = LoggerFactory.getLogger(AccountController.class);

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AccountRepository accountRepository;

    @GetMapping(path="/all")
    public Iterable<Account> getAllAccounts() {
        // This returns a JSON with the accounts
        log.debug("Getting all accounts");

        return accountRepository.findAll();
    }

    @GetMapping
    public String loginAccount (@RequestParam(value = "email") String email,
                              @RequestParam(value = "password") String password) {
        log.debug("Getting the account by email and password");
        String accountId = "";
        try {
            if (isBlank(email) || isBlank(password)) {
                throw new HttpUnprocessableEntityException("Email or password is blank.");
            }
            Account serchedAccount = accountRepository.findByEmailAndPassword(email, password);

            if (serchedAccount == null) {
                log.debug("Account does not exist.");
                return "Account does not exist.";
            }
            accountId = String.valueOf(serchedAccount.getAccountId());
        } catch (Exception ex) {
            ex.printStackTrace();
            return "Error getting the Account: " + ex.toString();
        }
        return "The account id is: " + accountId + " ";
    }

    @PostMapping
    public String registerAccount (@RequestBody Account entity) {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        String accountId = "";
        try {
            if (entity == null || isBlank(entity.getEmail()) || isBlank(entity.getPassword())) {
                throw new HttpUnprocessableEntityException("Entity, email or password is blank.");
            }
            Account newAccount = accountRepository.findByEmail(entity.getEmail());

            if (newAccount != null) {
                log.debug("Account already registered.");
                return "Account already registered.";
            }
            log.debug("Creating an account");

            User usr = new User(entity);
            entity.setUser(usr);
            accountRepository.save(entity);
            accountId = String.valueOf(entity.getAccountId());
        } catch (Exception ex) {
            ex.printStackTrace();
            return "Error creating the account: " + ex.toString();
        }
        return "Account successfully created with id = " + accountId + " ";
    }

    @PutMapping(value = "/{accountId}")
    public Account updateAccount (@PathVariable(value = "accountId") Integer accountId,
                                 @RequestBody Account entity) {
        log.debug("Updating an account");
        try {
            Account entityBefore = accountRepository.findByAccountId(accountId);
            entity.setAccountId(accountId);
            entity.setCreatedAt(entityBefore.getCreatedAt());
            accountRepository.save(entity);
        } catch (Exception ex) {
            ex.printStackTrace();
            log.debug("Error updating the Account: " + ex.toString());
        }
        return entity;
    }

    @DeleteMapping(value = "/{accountId}")
    public void deleteAccount (@PathVariable(value = "accountId") Integer accountId) {
        log.debug("Deleting an account");
        try {
            Account deleteAccount = accountRepository.findByAccountId(accountId);
            accountRepository.delete(deleteAccount);
        } catch (Exception ex) {
            log.debug("Error deleting the Account: " + ex.toString());
        }
    }
}
